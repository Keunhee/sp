# OctaFlip 게임 - 상세 설명서

## 프로젝트 개요

OctaFlip은 두 명의 플레이어가 번갈아 가며 말을 이동시키는 턴제 보드 게임입니다. 게임은 서버-클라이언트 구조로 구현되어 네트워크를 통한 멀티플레이어 게임이 가능합니다. 또한 LED 매트릭스를 사용하여 물리적인 디스플레이에 게임 상태를 표시할 수 있습니다.

## 게임 규칙

1. **게임 보드**: 8x8 크기의 정사각형 보드입니다.
2. **말 배치**: 게임 시작 시 각 플레이어의 말은 보드의 네 모서리에 배치됩니다.
   - 빨간색(R): 좌측 상단(0,0)과 우측 하단(7,7)
   - 파란색(B): 우측 상단(0,7)과 좌측 하단(7,0)
3. **이동 규칙**:
   - 플레이어는 자신의 턴에 말 하나를 상하좌우 또는 대각선 방향으로 1칸 또는 2칸 이동할 수 있습니다.
   - 1칸 이동: 말은 원래 위치에 남아있고, 새 위치에도 말이 생깁니다 (말이 복제됩니다).
   - 2칸 이동: 말은 원래 위치에서 사라지고 새 위치로 이동합니다 (말이 뛰어넘습니다).
   - 2칸 이동 시 중간 칸은 비어있어야 합니다.
   - 이동 후 인접한 모든 상대 말은 현재 플레이어의 말로 변경됩니다 (뒤집기).
4. **패스**: 유효한 이동이 없는 경우 플레이어는 패스해야 합니다.
5. **게임 종료 조건**:
   - 한 플레이어의 말이 모두 사라진 경우
   - 보드가 가득 찬 경우 (빈 칸이 없는 경우)
   - 연속으로 두 번 패스가 발생한 경우
6. **승리 조건**: 게임 종료 시 보드에 말이 더 많은 플레이어가 승리합니다.

## 프로젝트 구조

### 핵심 모듈

1. **게임 로직 (octaflip.c/h)**
   - 게임 보드 관리
   - 이동 유효성 검증
   - 이동 적용 및 말 뒤집기
   - 게임 종료 조건 확인

2. **서버 (server.c)**
   - 클라이언트 연결 관리
   - 게임 진행 관리
   - 타이머 관리
   - 메시지 처리

3. **클라이언트 (client.c)**
   - 서버 연결
   - 게임 상태 표시
   - 자동 이동 생성
   - LED 매트릭스 제어

4. **JSON 라이브러리 (json.c/h)**
   - JSON 데이터 구조 및 조작
   - JSON 직렬화 및 역직렬화

5. **메시지 처리 (message_handler.c/h)**
   - 메시지 생성 및 파싱
   - 프로토콜 구현

6. **LED 매트릭스 제어 (led_matrix.c/h)**
   - LED 하드웨어 제어
   - 시뮬레이션 모드 제공

### 프로토콜 설명

클라이언트와 서버 간의 통신은 JSON 기반 메시지를 사용합니다:

1. **등록 메시지** (클라이언트 -> 서버)
   ```json
   {"type": "register", "username": "Player1"}
   ```

2. **등록 응답 메시지** (서버 -> 클라이언트)
   ```json
   {"type": "register_ack"}
   ```
   또는
   ```json
   {"type": "register_nack", "reason": "Username already exists"}
   ```

3. **게임 시작 메시지** (서버 -> 클라이언트)
   ```json
   {"type": "game_start", "players": ["Player1", "Player2"], "first_player": "Player1"}
   ```

4. **당신 차례 메시지** (서버 -> 클라이언트)
   ```json
   {"type": "your_turn", "board": ["R......B", "........", ...], "timeout": 5.0}
   ```

5. **이동 메시지** (클라이언트 -> 서버)
   ```json
   {"type": "move", "username": "Player1", "sx": 0, "sy": 0, "tx": 1, "ty": 1}
   ```

6. **이동 응답 메시지** (서버 -> 클라이언트)
   ```json
   {"type": "move_ok", "board": ["R......B", ".R......", ...], "next_player": "Player2"}
   ```
   또는
   ```json
   {"type": "invalid_move", "board": [...], "next_player": "Player1"}
   ```

7. **패스 메시지** (서버 -> 클라이언트)
   ```json
   {"type": "pass", "next_player": "Player2"}
   ```

8. **게임 종료 메시지** (서버 -> 클라이언트)
   ```json
   {"type": "game_over", "scores": {"Player1": 35, "Player2": 29}}
   ```

## 구현 세부사항

### 게임 보드 표현

게임 보드는 8x8 크기의 문자 배열로 표현됩니다:
- 'R': 빨간색 플레이어의 말
- 'B': 파란색 플레이어의 말
- '.': 빈 칸

### 이동 생성 알고리즘

클라이언트는 다음 알고리즘을 사용하여 자동으로 최적의 이동을 생성합니다:
1. 모든 가능한 이동에 대해 이동 후 상태를 시뮬레이션
2. 각 이동의 점수를 계산: (자신의 말 수) - (상대의 말 수)
3. 가장 높은 점수를 가진 이동 선택

### LED 매트릭스 제어

LED 매트릭스는 8x8 보드를 64x64 픽셀 해상도로 표시합니다:
- 빨간색: 빨간색 플레이어의 말
- 파란색: 파란색 플레이어의 말
- 녹색: 빈 칸
- 흰색: 그리드 선

하드웨어가 없을 경우 시뮬레이션 모드로 동작하며, 콘솔에 보드 상태를 출력합니다.

## 빌드 및 실행 방법

### 컴파일

```bash
make clean
make
```

### 서버 실행

```bash
./server
```

### 클라이언트 실행

```bash
./client -ip <IP주소> -port <포트> -username <사용자명> [-led]
```

### 테스트 실행

```bash
./run_test.sh      # 간단한 테스트
./run_full_test.sh # 전체 테스트
```

## 성능 최적화

- **스레드 사용**: 클라이언트는 별도의 스레드를 사용하여 서버로부터 메시지를 수신
- **비차단 소켓**: 서버와 클라이언트 모두 비차단 소켓을 사용하여 IO 효율성 증가
- **메모리 관리**: 동적 할당된 메모리는 사용 후 적절히 해제
- **뮤텍스 사용**: 스레드 간 공유 데이터 접근 시 뮤텍스를 사용하여 데이터 무결성 보장

## 한계 및 확장 가능성

1. **UI 개선**: 현재는 콘솔 기반 UI를 사용하지만, 그래픽 UI로 확장 가능
2. **AI 개선**: 현재 사용하는 간단한 휴리스틱 대신 더 정교한 AI 알고리즘 적용 가능
3. **네트워크 보안**: 현재는 보안 기능이 없으므로, TLS/SSL 등을 적용하여 보안 강화 가능
4. **다인용 게임**: 현재는 2인용 게임만 지원하지만, 다인용 게임으로 확장 가능